#pragma config(UART_Usage, UART2, uartVEXLCD, baudRate38400, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    powerExpander,  sensorNone)
#pragma config(Sensor, dgtl1,  leftcoder,      sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightcoder,     sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  solenoid,       sensorDigitalOut)
#pragma config(Sensor, I2C_1,  LeftClaw,       sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  RightClaw,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  leftb,          sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  rightb,         sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           clawL,         tmotorVex393_HBridge, openLoop, driveLeft, encoderPort, I2C_1)
#pragma config(Motor,  port2,           leftbase,      tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           rightbase,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           clawR,         tmotorVex393_MC29, openLoop, driveRight, encoderPort, I2C_2)
#pragma config(Motor,  port5,           armLT,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           armLB,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           armLB2,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           armRT,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           armRB,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          armRB2,        tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform, so that we can use the proper equipment during the competition.
#pragma platform(VEX2)

// Select Download method as "competition", needed for the matches
#pragma competitionControl(Competition)

//Main competition background code...do not modify, needed so that we can sync motors and send signals!
#include "Vex_Competition_Includes.c"
#include "SmartMotorLib.c"

int joy_x;            // will hold the X value of the analog stick (left and right on the analog sticks, more explanation below).
int joy_y;            // will hold the Y value of the analog stick (up and down on the analog sticks, more explanation below).
int threshold = 10;   // helps to eliminate 'noise' from a joystick that isn't perfectly at rest, which means that if the joystick is not above a 10 degree tilt (let's say),no motors are moving.
											// Also helps to prevent from accidental tilting of the analog sticks on the VEX controller, this is VERY important,as we do not want the robot moving if the joysticks are being utilized.

// LCD variables, will display things when coded, code for it is below, we are defining it right now.
int display=1, buttonState6D=0, buttonState5D=0, powerMotor;

string exp_bat, main_bat, back_bat, main_string="Main:", exp_string="Exp:", back_string="BackUp:", letter, letter1, letter2, full, full1, full2; //battery levels
int move1, move2, move, lenth, lenth1, lenth2, print=0, print_last=0, print1=0, print2=0, print1_last=0, print2_last=0;


void LCD(){//task that is required to display information to the LCD screen on the robot.

	bLCDBacklight = true; //turns the backlight on for the LCD screen.

	if(display == 1){// Main LCD screen shows target rpm, rpm, and all battery voltages
		clearLCDLine(0); //for the top line that always updates
		displayLCDString(0, 0, "Tar:");//target will be on the first line left side
		//displayLCDNumber(0, 4, "69", 0);
		displayLCDString(0, 8, "RPM:");//rpm will be top line and right side
		//displayLCDNumber(0, 12, "69", 0);


		//for the bottom line and moving text, only runs when the time has passed
		move=move+1;
		main_string=" Main:";
		exp_string=" Exp:";
		back_string=" BackUp:";
		sprintf(main_bat,"%1.2f%s",nImmediateBatteryLevel/1000.0,"v");//calculates the battery voltages
		sprintf(exp_bat,"%1.2f%s",((float)SensorValue[powerExpander]/284.0),"v");
		sprintf(back_bat,"%1.2f%s",BackupBatteryLevel/1000.0,"v");
		//adds all of the battery voltages to one sting
		strcat(main_string,main_bat);

		strcat(exp_string,exp_bat);
		strcat(main_string,exp_string);

		strcat(back_string,back_bat);
		strcat(main_string,back_string);
		//deleates the extra that is not needed

		lenth=strlen(main_string);//saves the length
		print=print_last;//sets the starting point

		if(move>300){
			print_last++;
			move =0;
		}
		if(print_last>lenth){//resets if it is past the length of the string
			print_last=0;
		}

		//clears the line before printing
		for(int x=0;x<16;x++){//for loop that prints each indivdual charater to the screen
			letter="";
			letter=stringGetChar(main_string,print);
			strcat(full,letter);// finds the char from the string then prints it

			print=print+1;
			if(print>lenth){
				print=0;
			}
		}
		clearLCDLine(1);
		displayLCDString(1,0,full);
		full="";
	}

	if(display == 2){// prints out RPM and target RPM
		clearLCDLine(0);
		clearLCDLine(1);
		displayLCDString(0, 0, "TargetRPM:");
		//displayLCDNumber(0, 11, targetRPM, 0);
		displayLCDString(1, 0, "CurrentRPM:");
		//displayLCDNumber(1, 11, motor_velocity, 0);

	}
	else if (display == 3){	//prints power expander power and also cortex battery
		sprintf(main_bat,"%1.2f%s",nImmediateBatteryLevel/1000.0,"v");
		sprintf(exp_bat,"%1.2f%s",((float)SensorValue[powerExpander]/284.0),"v");
		clearLCDLine(0);//clears the lines before printing
		clearLCDLine(1);

		displayLCDString(0, 0, "Main Bat:");
		displayLCDString(0, 10, main_bat );
		displayLCDString(1, 0, "Exp Bat:");
		displayLCDString(1, 10, exp_bat);
	}

	else if(display == 4){//shows what code is loaded onto the cortex
		clearLCDLine(0);
		clearLCDLine(1);
		displayLCDString(0, 0, "Loaded Code:");
		displayFileName(1, 0);

	}
	else if(display == 5){//shows the motor output to the wheels
		clearLCDLine(0);
		clearLCDLine(1);
		displayLCDString(0, 0, "Motor power:");
		displayLCDNumber(1,12,powerMotor, 0);

	}
	if( 0 != nLCDButtons){//Checks to see if a button is pressed on LCD
		display = nLCDButtons;
	}
}





/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks
	// running between Autonomous and Driver controlled modes. You will need to
	// manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;
	SmartMotorsInit();
	SmartMotorLinkMotors(clawL,clawR); //linking both the claw motors together, should help with motor synchronization.
	SmartMotorLinkMotors(leftbase,rightbase);//linking the motors on the left side of the base to the right side for better syncronization while driving.
	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous()
{ //Autonomous mode goes straight to fence goes back to midway line then goes left to cube and onwards to midway fence to chuck it over
	//Assume starting at right side of field
	//Currently using normal motors
	//High speed motor = 392 ticks per revolution
	//Normal speed Motor= 627.2 ticks per revolution

	nMotorEncoder(LeftClaw)=0;
	nMotorEncoder(RightClaw)=0;
	nMotorEncoder(leftb)=0;
	nMotorEncoder(rightb)=0;
	nMotorEncoder(clawL)=0;
	nMotorEncoder(clawR)=0;
	nMotorEncoder(leftbase)=0;
	nMotorEncoder(rightbase)=0;

	//// claw "wings" out to half extension
	setMotor(clawL, -60);
	setMotor(clawR, 60);
	wait1Msec(150);
	setMotor(clawL, 0);
	setMotor(clawR, 0);

	//&& (nMotorEncoder(RightClaw)<-98)


	//pause for 0.1secs
	setMotor(leftbase, 0);
	setMotor(rightbase, 0);
	wait1Msec(100);


	// go forward
	//keep in mind that the motor are reversed hence the reverse values FOR RIGHTBASE
	//goes upfront a bit then grabs the star
	setMotor(leftbase, 127);
	setMotor(rightbase, -127);
	wait1Msec(180);
	//pause for 0.5 secs
	setMotor(leftbase, 0);
	setMotor(rightbase, 0);
	wait1Msec(500);
	//claw "wings" out to partial extension
	setMotor(clawL, -60);
	setMotor(clawR, 60);
	wait1Msec(150);
	//pause for 0.4 secs after grab
	setMotor(clawL, 0);
	setMotor(clawR, 0);
	wait1Msec(400);


	//forward to the fence
	setMotor(leftbase, 127);
	setMotor(rightbase, -127);
	wait1Msec(980);
	//pause for 0.5 seconds.
	setMotor(leftbase, 0);
	setMotor(rightbase, 0);
	wait1Msec(500);
	//raise arm full power for 2.4 seconds.
	setMultipleMotors(-127, armLB,armLB2,armLT);
	setMultipleMotors(127, armRB,armRB2,armRT);
	wait1Msec(2400);
	//pause arm for 0.8 seconds.
	setMultipleMotors(0, armLB,armLB2,armLT);
	setMultipleMotors(0, armRB,armRB2,armRT);
	wait1Msec(1000);
	//claw "wings" out to let go of star it is holding
	setMotor(clawL, 60);
	setMotor(clawR, -60);
	wait1Msec(400);
	//pause for 1.0 secs
	setMotor(clawL, 0);
	setMotor(clawR, 0);
	wait1Msec(1000);
	//arm comes down same value of time when it is going up
	setMultipleMotors(127, armLB,armLB2,armLT);
	setMultipleMotors(-127, armRB,armRB2,armRT);
	wait1Msec(2400);
	//pause arm for 0.5 secs
	setMultipleMotors(0, armLB,armLB2,armLT);
	setMultipleMotors(0, armRB,armRB2,armRT);
	wait1Msec(500);


	//goes backward to mid line
	//setMotor(leftbase,-127);
	//setMotor(rightbase, 127);
	//wait1Msec(400);

	//turn left(towards the cube)

	//setMotor(leftbase,-127);
	//setMotor(rightbase, -127);
	//wait1Msec(800);

}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task usercontrol()
{


	SmartMotorPtcMonitorEnable(); //Enabling the Smart motor variable tracking, pretty much needed to help us debug this whole program.
	SmartMotorRun();//Run the smart motor library before the actual driving as without doing this we cannot use SmartMotors.

	// User control code here, inside the loop

	while (true)//We use a while loop here for better signal connection for the inputs on the joystick to the cortex.
	{
		// This is the main execution loop for the user control program.Anything the driver can do should be in here.
		LCD(); //Activate the LCD screen so we can see things on it.

		/////***** DRIVE CODE *****\\\\\
		// Code to move Forward or Backward

		//#Debug Mode/Getting Variables from X and Y

		//Variables for X
		if (abs(vexRT[Ch1]) > threshold)//If the joystick is tilted above the threshold (10 degrees let's say), activate the following code.
		{
			joy_x = vexRT[Ch1];//set the variable to channel one (the RIGHT analog stick, left and right).
		}
		else //if the joystick is not tilted above the threshold, leave the motors off. This is to elimate noise on the motor, and another protection against accidental tilting of the analog sticks.
		{
			joy_x = 0;
		}

		//Variables for Y
		if (abs(vexRT[Ch3]) > threshold)//If the joystick is tilted above the threshold (10 degrees let's say), activate the following code.
		{
			joy_y = -vexRT[Ch3]; //set the variable to channel three (the LEFT analog stick, up and down). it is negative, otherwise it would have airplane mode (where tilting down would drive it foward, and the tiling up would drive it backward).
		}
		else //if the joystick is not tilted above the threshold, leave the motors off. This is to elimate noise on the motor, and another protection against accidental tilting of the analog sticks.
		{
			joy_y = 0;
		}

		//Drive Code

		SetMotor(leftbase,(joy_x + joy_y));
		SetMotor(rightbase,(joy_x - joy_y));

		/////***** ARM CODE *****\\\\\

		if(vexRT[Btn8U]==1) //If button 8U is pressed, do this. This section of code raises the arm up, so that we can throw stars or cubes over the fence.
		{
			motor[armLT]=-127;
			motor[armLB]=-127;
			motor[armLB2]=-127;
			motor[armRT]=127;
			motor[armRB]=127;
			motor[armRB2]=127;
			powerMotor=127;
		}

		else if(vexRT[Btn8D]==1)//If button 8D is pressed, do this. This section of code brings it back down to the resting position.
		{
			motor[armLT]=127;
			motor[armLB]=127;
			motor[armLB2]=127;
			motor[armRB]=-127;
			motor[armRT]=-127;
			motor[armRB2]=-127;
			powerMotor=-127;
		}

		else //While no buttons are pressed, do this. This code is designed to keep the arm in position, that the weight of the arm is not falling.
		{
			motor[armLT]=5;
			motor[armLB]=5;
			motor[armLB2]=5;
			motor[armRT]=-5;
			motor[armRB]=-5;
			motor[armRB2]=-5;
		}



		if(vexRT[Btn6U]==1) //While Button 6U is pressed, do this. This section of code allows us to open the claw on the front of the robot.
		{

			setMotor(clawL,-127);
			setMotor(clawR,127);

		}

		else if(vexRT[Btn5U]==1)//While Button 5U is pressed, do this. This section of code allows us to close the claw on the front of the robot.
		{

			setMotor(clawL,127);
			setMotor(clawR,-127);
		}

		else //if no buttons are pressed, turn the motors off, preventing noise and the possible risk of burning out the motors.
		{
			setMotor(clawL,0);
			setMotor(clawR,0);

		}



	}
}
